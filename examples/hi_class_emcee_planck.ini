[runtime]
# The emcee sampler, which uses the Goodman & Weare algorithm
sampler = emcee
root = ${PWD}

[emcee]
# The emcee sampler uses the concept of walkers, a collection
# of live points.  Sampling is done along lines that connect
# pairs of walkers.  The number of walkers must be at least
# 2*nparam + 1, but in general more than that usually works
# better.
walkers = 32
# This many samples is overkill, just to make the plots
# look a lot nicer
samples = 3
# This is the interval at which convergence diagnostics
# are performed
nsteps = 10

[output]
filename = output/planck.txt
format = text
verbosity = debug

[DEFAULT]
# This value is used below as %(planck_path)s
planck_path = likelihood/planck2018/baseline/plc_3.0


[pipeline]
# These names refer to sections later in the file:
modules = consistency hi_class planck
values = examples/hi_class_test_values.ini
quiet=F
debug=T
timing=F


[planck]
# Planck 2018 high ell TT,TE and EE + low ell TT + low ell EE
# (in Planck notations = TT+lowE) without CMB lensing
file = likelihood/planck2018/planck_interface.so
data_1 = %(planck_path)s/hi_l/plik/plik_rd12_HM_v22b_TTTEEE.clik
data_2 = %(planck_path)s/low_l/commander/commander_dx12_v3_2_29.clik
data_3 = %(planck_path)s/low_l/simall/simall_100x143_offlike5_EE_Aplanck_B.clik


[consistency]
# The consistency module translates between our chosen parameterization
# and any other that modules in the pipeline may want (e.g. camb)
file = ./utility/consistency/consistency_interface.py

[hi_class]
file = boltzmann/hi_class/hi_class_interface.py
lmax = 2850
debug = T
zmax = 4.0
cmb = T
mpk = F
lensing = T
#class_non_linear = halofit

# HI_CLASS_NEW: all the parameters of (hi_)class can be written here prepending
# class_ or hi_class_ (it is equivalent). This way we do not need to modify
# the hi_class interface for every new parameter we need.
hi_class_gravity_model = propto_omega
hi_class_expansion_model = lcdm
